<!-- -*- mode: HTML; time-stamp-line-limit: -18; -*- -->
<?xml version="1.0" encoding="iso-8859-1"?> 
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <link rel="stylesheet" href="style.css" type="text/css"/>
       <title>GSLL Documentation</title>
  </head>
  <body>
    <div class="body">

 <div class="header">
  <h1>GSLL Documentation</h1>
  <h2>GSLL Documentation</h2>
 </div>

 <h3>General Advice</h3>
 <div class="content">

 <p>There is little separate documentation for GSLL.  Instead, the
 following techniques for using the API are advised:</p>
 <ul>
 <li>Find the appropriate function(s) in the <a
 href="http://www.gnu.org/software/gsl/manual/">GSL
 documentation</a>.</li>
 <li>Use the GSLL function <code>gsl-lookup</code>
  to find the equivalent GSLL function, for example
<pre>
(gsl-lookup "gsl_sf_elljac_e")
JACOBIAN-ELLIPTIC-FUNCTIONS
T
</pre>
to find that the Lisp function name is <code>#'jacobian-elliptic-functions</code>.  
  </li>
 <li>Look at the documentation for that Lisp function, e.g.
   <pre>(documentation #'jacobian-elliptic-functions 'function)
"The Jacobian elliptic functions sn(u|m),
  cn(u|m), dn(u|m) computed by descending Landen transformations."
   </pre>
   to get an explanation of the arguments etc.
 </li>
 <li>Use the function <code>(examples)</code> without an argument to
 get a list of example categories.  Then use the function with a
 category name as the argument to get a list of examples under that
 category, for example
   <code>(examples 'higher-moments)</code>.  The result will be a list
   of forms, each providing an example of usage in the relevant topic.
   If the
 <a href="http://www.gnu.org/software/gsl/manual/">GSL documentation</a>
 provides an example, there will usually be the same or similar
 example provided in GSLL.</li>
 </ul>
 It is advisable to look at the examples first for calculations that
 require more complex setup (generally, the later chapters in the GSL
 manual).
 </div>

 <h3>GSL objects and letm </h3>
There are a number of GSL structures available that must be manually
allocated, possibly set, and freed.  In
order to make this as convenient as possible, the macro
<code>letm</code> is provided.  This macro acts as a
<code><a
href="http://www.lispworks.com/documentation/HyperSpec/Body/s_let_l.htm#letST">let*</a></code>,
with the additional feature that if the init-form is one of GSL objects

<pre>
acceleration basis-spline chebyshev combination complex-workspace
discrete-random eigen-herm eigen-hermv eigen-symm eigen-symmv
fdfsolver fit-workspace fminimizer fsolver hankel histogram
integration-workspace interpolation levin levin-truncated
matrix-* mfdfminimizer mfdfsolver mfminimizer mfsolver
monte-carlo-miser monte-carlo-plain monte-carlo-vegas
nonlinear-fdffit nonlinear-ffit permutation
quasi-random-number-generator random-number-generator spline
vector-* wavelet wavelet-workspace
</pre>
the appropriate object will be allocated and bound to the variable,
optionally set, and then freed when the body of the let is exited.
For Lisp environments with arglist prompting (such as SLIME), these
are functions whose symbols are exported so that an arglist prompt
will be visible; however, the function should not be used outside a
<code>letm</code> binding.

 <h3>Arrays</h3>
 <div class="content">
 <p>FIX: #m, #nm, <code>make-array*</code>
 <p>
 GSLL has many functions that work on vectors (one-dimensional arrays)
 and matrices (two-dimensional arrays).  GSLL supports all array element
 types that are supported by CFFI, the CL implementation, and GSL.
 This list is available in the
 variable <code>*array-element-types*</code>.  These arrays
 are <i>foreign-friendly</i>, meaning that on platforms that support
 it (currently only SBCL), the contents are directly available to the
 GSL functions without copying between the Lisp area and the C area of
 memory.
 <p>
 Common Lisp arrays should be created with <code>make-array*</code>;
 the syntax is similar to Common Lisp's <code>make-array</code>
 except that the second argument <code>element-type</code> is
 mandatory.  If this function is used, the resultant array is
 foreign friendly.  It can then be used as an argument in the letm
 binding.  Alternatively, a literal array can be created in the letm
 binding using the macros <code>a</code> (non-evaluating)
 or <code>a*</code> (evaluating).
 <p>
 Classes of vectors and matrices are names by appending the element
 type as hypenated words to "vector" or "matrix".  The following table
 shows the classes available on SBCL on an amd64 platform.
 <center>
  <table border=5 frame=all cellpadding=4 cellspacing=4 cols=6>
    <caption align=top>Element types, vector and matrix
    classes</caption>
    <thead>
      <tr><th>Element type<td><b>Vector class name</b><td><b>Matrix class name</b>
    </thead>
	<tbody>
	  <tr><td>single-float<td>vector-single-float<td>matrix-single-float
	  <tr><td>double-float<td>vector-double-float<td>matrix-double-float
	  <tr><td>(complex single-float)<td>vector-complex-single-float<td>matrix-complex-single-float
	  <tr><td>(complex double-float)<td>vector-complex-double-float<td>matrix-complex-double-float
	  <tr><td>(signed-byte 8)<td>vector-signed-byte-8<td>matrix-signed-byte-8
	  <tr><td>(unsigned-byte 8)<td>vector-unsigned-byte-8<td>matrix-unsigned-byte-8
	  <tr><td>(signed-byte 16)<td>vector-signed-byte-16<td>matrix-signed-byte-16
	  <tr><td>(unsigned-byte 16)<td>vector-unsigned-byte-16<td>matrix-unsigned-byte-16
	  <tr><td>(signed-byte 32)<td>vector-signed-byte-32<td>matrix-signed-byte-32
	  <tr><td>(unsigned-byte 32)<td>vector-unsigned-byte-32<td>matrix-unsigned-byte-32
	  <tr><td>(signed-byte 64)<td>vector-signed-byte-64<td>matrix-signed-byte-64
	  <tr><td>(unsigned-byte 64)<td>vector-unsigned-byte-64<td>matrix-unsigned-byte-64
	</tbody>
      </table>
    </center>
              
<p>
 The class name serves as the binding form in the letm.  For example,
 the following form sums two vectors:
<pre>
(letm ((vec1 (vector-double-float (a -3.21d0 1.0d0 12.8d0)))
       (vec2 (vector-double-float (a -1.88d0 -1.0d0 4.1d0))))
   (m+ vec1 vec2))
#&lt;VECTOR-DOUBLE-FLOAT #(-5.09d0 0.0d0 16.9d0)&gt;
</pre>
<p>
 Individual elements are obtained using <code>maref</code> (analogous
 to Lisp's <code>aref</code>), and are set
 with <code>setf maref</code>.  A complete CL array may
 be extracted with the function <code>#'cl-array</code>.  This array
 may subsequently be used in later GSL functions by providing it as
 the argument in the letm binding.
</p>

 <h3>Additional definitions</h3>
Some definitions are provided because of their usefulness, even though
GSL doesn't have them.  
<ul>
  <li><code>invert-matrix</code> finds the inverse of a matrix and uses
  GSL's LU decomposition functions.</li>
  <li>IEEE floating point number analysis.</li>
</ul>


 <h3>Status</h3>
 <div class="content">
 Consistent with the <a href="development.html">development</a>
 philosophy, most of the interface to the library is done.  Notes
 on particular chapters:
<ul>
<base href="http://www.gnu.org/software/gsl/manual/html_node/">
  <li>Reading and writing through the GSL library is not supported due
  to lack of support for foreign streams in Lisp.</li>
  <li>For <a href="Vectors-and-Matrices.html">Vectors and
	 Matrices</a>, subvectors and views are not defined.  For GSL
	 functions that take a stride, it is pre-set to 1 in GSLL.
<li><a href="BLAS-Support.html">BLAS</a> is completed, but with only very
 limited testing.
 <li><a href="Fast-Fourier-Transforms.html">FFTs</a> have not been done
 because GSL does not supply an example and it is not clear how it is
 used.  Contributions welcome. 
<li><a href="Simulated-Annealing.html">Simulated Annealing</a> is
 known to have problems in GSL and a replacement <a
 href="https://gna.org/projects/annealing">is being redesigned</a>; 
 the version distributed has been ported in GSLL but does not work.
<li><a href="Wavelet-Transforms.html">Wavelet Transforms</a> has been
 done but the results of the example do not agree with the GSL manual.
<li><a href="Discrete-Hankel-Transforms.html">Discrete Hankel
 Transforms</a> has been done but there is no example given in the GSL
 manual. 
<li><a href="Basis-Splines.html">Basis splines</a> example runs, but
 the GSL documentation does not provide the result for comparison.
</ul>
<p>
There are failures observed in the regression tests
<code>(lisp-unit:run-tests)</code>:
<ul>
<li>CLISP shows three "foreign callout errors." Remedy unknown.
<li>There are several regression failures that are apparently due to
changes in GSL between versions 1.8 and 1.10.  These are:
beta, chi-squared, dirichlet, elliptic-functions, fdist,
gamma-randist, negative-binomial.
</ul>

 <div class="footer">
    <hr>
    <address><a href="mailto:gsll-devel@common-lisp.net">Liam Healy</a></address>
<!-- hhmts start -->
    <small>
      Time-stamp: <2008-11-30 19:28:51EST documentation.html>
      </small>
<!-- hhmts end -->
 </div>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-3669275-1");
pageTracker._initData();
pageTracker._trackPageview();
</script>
 </body>
</html>
